# -*- coding: utf-8 -*-
"""Practical 2: Estimating LST from MODIS in GEE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1akte3snIkyFg-Wm18Yw_COxHBorc5nE5

**About the script:** This script is prepared for the forest information technology (FIT) 3rd semester students of Eberswalde University for Sustainable Development (HNEE).

**Developed by:** Gulam Mohiuddin

**1. Getting the Google Earth Engine Python API ready and activated**
"""

# installing libraries
!pip install geemap --upgrade
!pip install geopandas
!pip install osmnx

# loading necessary libraries
import os
import sys
import ee
import geemap
import osmnx as ox
import geopandas as gpd

# authentication
ee.Authenticate()

# initialize the GEE.
ee.Initialize(project='ee-mohigeo33')

"""**2. Introducing area of interest (AOI)**"""

# Phnom Penh, Cambodia
phnom_gdf = ox.geocode_to_gdf('Phnom Penh, Cambodia')
phnom_geojson = phnom_gdf.iloc[0].geometry.__geo_interface__
phnom_aoi = ee.Geometry(phnom_geojson)
roi = phnom_aoi

# visualising the AOI
Map = geemap.Map()
Map.addLayer(roi, {}, 'AOI')
Map.centerObject(roi, zoom= 10)
Map

"""**3. LST estimation with MODIS**

**About the MODIS thermal data:**

***MOD11A2.061 Terra Land Surface Temperature and Emissivity 8-Day Global 1km***

The MOD11A2 V6.1 product provides an average 8-day land surface temperature (LST) in a 1200 x 1200 kilometer grid. Each pixel value in MOD11A2 is a simple average of all the corresponding MOD11A1 LST pixels collected within that 8 day period. The MOD11A2 does a simple averaging of all daily LST values, without any filtering for specific QA bits. Each of the MOD11A2 QA values are set based on what majority of input daily QA values are for any given pixel.

***3.1 Setting the temporal parameters***
"""

# Temporal Parameters
year_start = 2014
year_end = 2015
month_start = 1
month_end = 12

start_date = ee.Date.fromYMD(year_start, month_start, 1)
end_date = ee.Date.fromYMD(year_end, month_end, 1).advance(1, 'month')

"""***3.2 Calling the MODIS thermal image collection and quality filtering***"""

# MODIS LST collection
COL_DAILY = 'MODIS/061/MOD11A1'
SCALE_LST = 0.02       # to Kelvin
K2C = -273.15          # Kelvin to Celsius

"""***Explanation of the quality filtering***

Every MODIS LST pixel comes with a QA code that tells us how reliable that temperature value is. The QA code has bits (tiny switches) that record things like:

     - Was the LST retrieved successfully?

     - Was the pixel clear or cloudy?

     - Was the retrieval quality good or questionable?

This function looks at those QA flags and keeps only the reliable pixels (good or acceptable quality) and masks out bad ones (like cloudy or failed retrievals).

*Please note that this isn’t just about cloud masking — it’s a general quality filter. Clouds are one reason a pixel can be flagged, but poor retrievals or processing issues are also excluded.*
"""

# Function 1: MODIS QA filter to remove cloudy and poor-quality LST pixels
# keep good/acceptable DAY pixels only
def mask_day_quality(img):
    qc = img.select('QC_Day')
    # Bits 0–1 (mandatory QA): 00 good, 01 other quality
    mandatory = qc.bitwiseAnd(3)
    good_or_ok = mandatory.eq(0).Or(mandatory.eq(1))
    # Bits 2–3 (data quality): 00 good data quality
    data_qual = qc.rightShift(2).bitwiseAnd(3)
    good_data = data_qual.eq(0)
    return img.updateMask(good_or_ok.And(good_data))

# Function 2: Converting temperature value to degree celcius
def to_celsius(img, band_name, out_name):
    return img.select(band_name).multiply(SCALE_LST).add(K2C).rename(out_name)

# Build the image collection collection
daily = (ee.ImageCollection(COL_DAILY)
         .filterBounds(roi)
         .filterDate(start_date, end_date))

# Checking the number of images in the built collection
n_images = daily.size().getInfo()
print("Number of images in collection:", n_images)

"""**3.3 Finding the best day-time and night-time image in terms of quality pixels for the same day**"""

# --- Score each daily image for valid DAY and valid NIGHT pixels in ROI ---
def add_valid_counts(img):
    dayC  = to_celsius(mask_day_quality(img), 'LST_Day_1km', 'LST_Day_C')
    # Night: just mask fills (0); we're not applying QA per your request
    night = img.select('LST_Night_1km').updateMask(img.select('LST_Night_1km').neq(0))

    day_valid   = dayC.mask().reduceRegion(ee.Reducer.sum(), roi, 1000, maxPixels=1e13).get('LST_Day_C')
    night_valid = night.mask().reduceRegion(ee.Reducer.sum(), roi, 1000, maxPixels=1e13).get('LST_Night_1km')

    return img.set({'day_valid': day_valid, 'night_valid': night_valid})

scored_both = daily.map(add_valid_counts)

# Keep only dates with at least some valid night pixels (and day)
both_ok = scored_both.filter(ee.Filter.gt('day_valid', 0)).filter(ee.Filter.gt('night_valid', 0))

# Pick the date maximizing the *combined* valid pixels (you can change to 'day_valid' if you prefer)
best_both = ee.Image(both_ok.sort(ee.String('day_valid').cat('+').cat(ee.String('night_valid')), False).first())
# Simpler: sort by sum (requires casting to Number)
best_both = ee.Image(both_ok.map(lambda im: im.set(
    'sum_valid', ee.Number(im.get('day_valid')).add(ee.Number(im.get('night_valid')))
)).sort('sum_valid', False).first())

the_day = ee.Date(best_both.get('system:time_start'))
date_str = the_day.format('YYYY-MM-dd').getInfo()
print('Chosen same-day (has day & night data):', date_str)

"""***3.4 Selecting the images for the selected day***"""

# --- Build day (QA) and night (no QA) images in °C, clipped & with metadata ---
best_dayC   = (to_celsius(mask_day_quality(best_both), 'LST_Day_1km',   'LST_Day_C')
               .clip(roi).copyProperties(best_both, best_both.propertyNames()))
best_nightC = (best_both.select('LST_Night_1km').updateMask(best_both.select('LST_Night_1km').neq(0))
               .multiply(0.02).add(-273.15).rename('LST_Night_C')
               .clip(roi).copyProperties(best_both, best_both.propertyNames()))

# --- Min/max (auto) for clean viz; fall back if no stats (shouldn’t happen after filter) ---
day_stats = ee.Image(best_dayC).select('LST_Day_C').reduceRegion(
    ee.Reducer.minMax(), roi, 1000, maxPixels=1e13
).getInfo() or {}

night_stats = ee.Image(best_nightC).select('LST_Night_C').reduceRegion(
    ee.Reducer.minMax(), roi, 1000, maxPixels=1e13
).getInfo() or {}


dmin = day_stats.get('LST_Day_C_min', 20);   dmax = day_stats.get('LST_Day_C_max', 45)
nmin = night_stats.get('LST_Night_C_min', 20); nmax = night_stats.get('LST_Night_C_max', 35)

print(f"Day LST °C:   {dmin:.2f} – {dmax:.2f}")
print(f"Night LST °C: {nmin:.2f} – {nmax:.2f}")

"""***3.5 Visualising the LST images for day-time and night-time together***"""

# Use nmin (night min) and dmax (day max) as the common stretch
cmin = nmin
cmax = dmax

# Common visualization parameters
palette = ['040274','2c7bb6','abd9e9','ffffbf','fdae61','d7191c']
vis_common = {'min': cmin, 'max': cmax, 'palette': palette}

# Visualize both with same stretch
Map = geemap.Map()
Map.centerObject(roi, 9)
Map.addLayer(ee.Image(best_dayC).select('LST_Day_C'),   vis_common, f'Day LST (°C) {date_str}')
Map.addLayer(ee.Image(best_nightC).select('LST_Night_C'), vis_common, f'Night LST (°C) {date_str}')

# # ROI outline
# Map.addLayer(ee.Image().paint(ee.FeatureCollection([ee.Feature(roi)]), 0, 2),
#              {'palette': ['black']}, 'ROI')

# One shared colorbar
Map.add_colorbar(vis_params=vis_common, label='LST (°C)')
Map

"""***Optional visualisation (with different legend for day and night time LST***"""

# --- Visualize both with legends ---
palette = ['040274','2c7bb6','abd9e9','ffffbf','fdae61','d7191c']
vis_day  = {'min': dmin, 'max': dmax, 'palette': palette}
vis_ngt  = {'min': nmin, 'max': nmax, 'palette': palette}

Map = geemap.Map()
Map.centerObject(roi, 9)
Map.addLayer(ee.Image(best_dayC).select('LST_Day_C'),   vis_day, f'Day LST (°C) {date_str}')
Map.addLayer(ee.Image(best_nightC).select('LST_Night_C'), vis_ngt, f'Night LST (°C) {date_str}')
# Map.addLayer(ee.Image().paint(ee.FeatureCollection([ee.Feature(roi)]), 0, 2),
#              {'palette': ['black']}, 'ROI')
Map.add_colorbar(vis_params=vis_day,  label='Day LST (°C)')
Map.add_colorbar(vis_params=vis_ngt,  label='Night LST (°C)')
Map